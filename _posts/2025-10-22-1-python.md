---
layout: single
title: "[Python] 1.2 About Python Modules" 
date: 2025-10-22
categories: Python
#header:
  #overlay_image: /assets/images/docker-container-tech.svg
  #overlay_filter: 0.5
  #teaser: /assets/images/docker-container-tech.svg
  #caption: "Create Docker Image"
Typora-root-url: ../
---

# Python Modules: Organizing and Reusing Your Code

As your Python programs grow larger and more complex, you'll want to organize your code into separate files for better maintainability and reusability. This is where modules come in handy.

A module in Python is simply a file containing Python code. It can define functions, classes, and variables, and can also include runnable code.

## Creating your first module

Let's create a simple module called `mod1.py`:

```python
# mod1.py
def add(a, b): 
    return a+b

def sub(a, b): 
    return a-b

if __name__ == "__main__":
    print(add(1, 4))
    print(sub(4, 2))
```

This module contains two functions: `add()` and `sub()`. The `if __name__ == "__main__":` block ensures that the print statements only run when the file is executed directly, not when it's imported as a module.

## Using modules with import

Once you've created a module, you can use it in other Python files by importing it:

```python
import mod1

result = mod1.add(3, 5)
print(result)  # Output: 8

result = mod1.sub(10, 4)
print(result)  # Output: 6
```

## Different ways to import

### Importing specific functions

Instead of importing the entire module, you can import specific functions:

```python
from mod1 import add, sub

result = add(3, 5)  # No need to use mod1.add()
print(result)  # Output: 8
```

### Importing with aliases

You can give modules or functions different names when importing:

```python
import mod1 as calculator
from mod1 import add as addition

result = calculator.sub(10, 3)
print(result)  # Output: 7

result = addition(5, 5)
print(result)  # Output: 10
```

### Importing everything

You can import all functions from a module (though this is generally not recommended):

```python
from mod1 import *

result = add(2, 3)
result2 = sub(8, 4)
```

## Module with classes and variables

Let's look at a more complex module `mod2.py`:

```python
# mod2.py
PI = 3.141592

class Math: 
    def solv(self, r): 
        return PI * (r ** 2) 

def add(a, b): 
    return a+b 
```

This module contains:
- A variable `PI`
- A class `Math` with a method `solv()` that calculates the area of a circle
- A function `add()`

## Using the complex module

```python
import mod2

# Using the variable
print(mod2.PI)  # Output: 3.141592

# Using the class
math_obj = mod2.Math()
area = math_obj.solv(5)  # Calculate area of circle with radius 5
print(f"Area: {area}")  # Output: Area: 78.5398

# Using the function
result = mod2.add(10, 20)
print(result)  # Output: 30
```

## The `__name__` variable

Every Python module has a built-in variable called `__name__`. When a module is run directly, `__name__` is set to `"__main__"`. When it's imported, `__name__` is set to the module's name.

This allows you to include code that only runs when the module is executed directly:

```python
# In mod1.py
if __name__ == "__main__":
    print("This module is being run directly")
    print(add(1, 4))
    print(sub(4, 2))
```

## Module search path

Python looks for modules in the following order:
1. Current directory
2. PYTHONPATH environment variable directories
3. Standard library directories
4. Site-packages directory

## Best practices for modules

1. **Use descriptive names**: Choose clear, descriptive names for your modules
2. **Keep related functionality together**: Group related functions and classes in the same module
3. **Use docstrings**: Document your modules, functions, and classes
4. **Avoid `from module import *`**: It can lead to namespace pollution
5. **Use `if __name__ == "__main__":`**: Include test code or examples that only run when the module is executed directly

## Summary

Modules are a powerful way to organize your Python code:
- Create modules by saving Python code in `.py` files
- Import modules using `import module_name`
- Access module contents using dot notation: `module_name.function_name`
- Use `from module import function` to import specific items
- The `__name__ == "__main__"` pattern allows code to run only when executed directly

Modules help you write cleaner, more maintainable code by promoting code reuse and logical organization.